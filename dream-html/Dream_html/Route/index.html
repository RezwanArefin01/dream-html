<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Route (dream-html.Dream_html.Route)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">dream-html</a> &#x00BB; <a href="../index.html">Dream_html</a> &#x00BB; Route</nav><header class="odoc-preamble"><h1>Module <code><span>Dream_html.Route</span></code></h1><p>Bidirectional routes with type-safe path segment parsing and printing using OCaml's built-in format strings, and support for scoped middleware.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> v3.9.0</li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>(_, _) t</span></span></code></div><div class="spec-doc"><p>A route that can handle a templated request path and also print the filled value of the templated path using its parameters.</p><p>The first type parameter represents the type of the request handler. Eg, if the format string is <code>&quot;/foo&quot;</code>, the handler will have type <code>Dream.request -&gt; Dream.response Dream.promise</code>. If the format string is <code>&quot;/foo/%s&quot;</code>, the handler will have type <code>Dream.request -&gt; string -&gt; Dream.response Dream.promise</code>, and so on depending on the type specifiers in the format string.</p><p>The second type parameter represents the type of the <code>link</code> attribute printer. Eg, if the format string is <code>&quot;/foo&quot;</code>, the printer will have type <code>Dream_html.attr</code>. If the format string is <code>&quot;/foo/%s&quot;</code>, the printer will have type <code>string -&gt; Dream_html.attr</code>, and so on.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="optlabel">?meth</span>:<span class="xref-unresolved">Dream</span>.method_ <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'r</span>, unit, <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'p</span>, unit, string, <a href="../index.html#type-attr">attr</a>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'r</span>, <span class="type-var">'p</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make ?meth request_fmt attr_fmt handler</code> is a route which handles requests with <code>meth</code> if specified, or any method otherwise.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">request_fmt</span> <p>format string is used to match against requests. It accepts the following format specifiers:</p><p><code>%s</code> matches against any sequence of characters upto (excluding) a <code>/</code>.</p><p><code>%*s</code> matches against the rest of the path, and then passes as handler params the number of characters captured as well as the captured substring. This can be used as a catch-all, eg to respond with a customized 'not found' message.</p><p><code>%d</code> matches against any integer.</p><p><code>%c</code> matches against any single character.</p><p><code>%%</code> at the <i>end</i> of the route format string matches against an optional trailing <code>/</code> character, allowing you to flexibly handle requests either way.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">attr_fmt</span> <p>format string is used to print out the filled value of the route with its parameters as a dream-html typed attribute. The two are different because they must be specified as literals and have different types for parsing and printing. ℹ️ For convenience, a PPX is provided that allows typing the format literal just once and duplicates it for you: see the <code>dream-html.ppx</code> library.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">handler</span> <p>takes the Dream request and any parameters that are parsed from the path as arguments and returns a Dream response.</p><p>Examples:</p><pre class="language-ocaml"><code>let get_account_version =
  make
    ~meth:`GET
    &quot;/accounts/%s/versions/%d&quot;
    &quot;/accounts/%s/versions/%d&quot;
    (fun _req acc ver -&gt;
      Dream.html (Printf.sprintf &quot;Account: %s, version: %d&quot; acc ver))

let get_order =
  make ~meth:`GET &quot;/orders/%s&quot; &quot;/orders/%s&quot; (fun _ id -&gt; Dream.html id)</code></pre></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-format"><a href="#val-format" class="anchor"></a><code><span><span class="keyword">val</span> format : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>format route</code> is the template string used to match request paths against the <code>route</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-link"><a href="#val-link" class="anchor"></a><code><span><span class="keyword">val</span> link : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">'p</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'p</span>, unit, string, <a href="../index.html#type-attr">attr</a>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span></span></code></div><div class="spec-doc"><p><code>link route</code> is a dream-html attribute value that prints out the filled path of the <code>route</code> given its parameters. Use this instead of hard-coding your route URLs throughout your app, to make it easy to refactor routes with minimal effort.</p><p>Eg:</p><pre class="language-ocaml"><code>open Dream_html
open HTML

a [href (Route.link get_order) &quot;yzxyzc&quot;] [txt &quot;My Order&quot;]</code></pre><p>Renders: <code>&lt;a href=&quot;/orders/yzxyzc&quot;&gt;My Order&lt;/a&gt;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-handler"><a href="#val-handler" class="anchor"></a><code><span><span class="keyword">val</span> handler : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Dream</span>.handler</span></code></div><div class="spec-doc"><p><code>handler route</code> converts the <code>route</code> into a Dream handler.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(||)"><a href="#val-(||)" class="anchor"></a><code><span><span class="keyword">val</span> (||) : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>, <a href="../index.html#type-attr">attr</a>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>route1 || route2</code> joins together <code>route1</code> and <code>route2</code> into a new route so that requests targeting either of them will match. Use this to build your app's routes. Eg, in Dream your routes might look like:</p><pre class="language-ocaml"><code>Dream.router [
  Dream.get &quot;/echo/:word&quot; Echo.get;
  Dream.post &quot;/echo/:word&quot; Echo.post;
]</code></pre><p>With <code>( || )</code> it would look like:</p><pre class="language-ocaml"><code>(* echo.ml *)
open Route

let get = make ~meth:`GET &quot;/echo/%s&quot; &quot;/echo/%s&quot; (fun _ word -&gt;
  Dream.html word)

let post = make ~meth:`POST &quot;/echo/%s&quot; &quot;/echo/%s&quot; (fun _ word -&gt;
  Dream.html ~status:`Created word)

(* main.ml *)
handler (
  Echo.get ||
  Echo.post
)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&amp;&amp;)"><a href="#val-(&amp;&amp;)" class="anchor"></a><code><span><span class="keyword">val</span> (&amp;&amp;) : <span><span class="xref-unresolved">Dream</span>.middleware <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Dream</span>.middleware <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Dream</span>.middleware</span></code></div><div class="spec-doc"><p><code>middleware1 &amp;&amp; middleware2</code> joins together two Dream middlewares so that <code>middleware1</code> is applied first, then <code>middleware2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scope"><a href="#val-scope" class="anchor"></a><code><span><span class="keyword">val</span> scope : 
  <span><span><span>(<span>int <span class="arrow">&#45;&gt;</span></span>
    <span>string <span class="arrow">&#45;&gt;</span></span>
    <span class="type-var">'r</span>,
    unit,
    <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>,
    <span>int <span class="arrow">&#45;&gt;</span></span>
    <span>string <span class="arrow">&#45;&gt;</span></span>
    <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'d</span>, unit, string, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Dream</span>.response <span class="xref-unresolved">Dream</span>.promise</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Dream</span>.request <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">_</span>, <span class="type-var">'e</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>scope request_prefix attr_prefix middleware route</code> is a route that matches against paths which have a <code>request_prefix</code>, and handles those requests by applying the <code>middleware</code> and the <code>route</code> handler. Eg:</p><pre class="language-ocaml"><code>let add_header prev req =
  let open Lwt.Syntax in
  let+ resp = prev req in
  Dream.add_header resp &quot;X-Api-Server&quot; &quot;Dream&quot;;
  resp

let get_order =
  make ~meth:`GET &quot;/orders/%s&quot; &quot;/orders/%s&quot; (fun _ id -&gt; Dream.html id)

let get_order_v2 = scope &quot;/v2&quot; &quot;/v2&quot; add_header get_order</code></pre><p>In the example above, <code>get_order_v2</code> will match against requests with paths like &quot;/v2/orders/%s&quot;, then strip out the <code>/v2</code> prefix, apply the <code>add_header</code> middleware, and handle the request with the <code>get_order</code> route.</p><p>⚠️ However, be aware that adding a scope on top of an existing route does not change that route's path, so eg if you use the <code>get_order</code> route to print links, but route against the <code>get_order_v2</code> route, the links will not work.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">attr_prefix</span> <p>is used to prefix the route link correctly as well when it is printed as an attribute.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pp</code> is a formatter that prints out a simple summary of the route, eg <code>GET /foo/%s</code> or just <code>/foo/%s</code> if the route matches any method.</p></div></div></div></body></html>
